### Conceptual Exercise

Answer the following questions below:

- What is a JWT?
	- JWT stands for JSON Web Token. It is a compact, URL-safe means of representing claims between two parties. These claims are encoded as a JSON object and are digitally signed, typically using a secret or a public/private key pair. 
	- JWTs are commonly used for authentication and information exchange in web applications and APIs.
	- JWTs consist of three parts separated by dots: the header, the payload, and the signature. 

- What is the signature portion of the JWT?  What does it do?
	- The signature is generated by encoding the header and payload, along with a secret or private key, using the specified algorithm. This signature is used to verify that the token has not been tampered with.

- If a JWT is intercepted, can the attacker see what's inside the payload?
	- If a JWT is intercepted by an attacker, they can see the contents of the payload unless the payload has been encrypted. By default, JWT payloads are encoded in Base64, which is not a secure encryption method but rather a simple encoding format. This means that the payload can be easily decoded by anyone who intercepts the token.
	- Therefore, it's crucial not to include sensitive information in the payload of a JWT unless it is encrypted. If confidentiality of the payload data is a concern, encryption should be applied before encoding the payload into the JWT. 
	- Additionally, even if the payload is not encrypted, JWTs should be transmitted over secure channels (e.g., HTTPS) to minimize the risk of interception and tampering.

- How can you implement authentication with a JWT?  Describe how it works at a high level.

	1. User Authentication: When a user logs in to the system, their credentials (such as username and password) are verified by the authentication server.

	2. JWT Generation: Upon successful authentication, the server creates a JWT containing relevant information about the user (such as user ID, role, or other claims) in the payload. The server then signs the JWT using a secret key to prevent tampering.

	3. JWT Issuance: The server sends the JWT back to the client as part of the authentication response, typically in the form of an HTTP response header or in the response body.

	4. Client Storage: The client (e.g., a web browser or mobile app) stores the JWT securely, typically in local storage, session storage, or a cookie, depending on the security requirements and platform capabilities.

	5. Subsequent Requests: For subsequent requests that require authentication, the client includes the JWT in the request, typically in the Authorization header using the Bearer scheme.

	6. JWT Verification: The server receives the JWT with each request that requires authentication. It verifies the JWT's signature using the secret key to ensure its authenticity and integrity.

	7. Access Control: Once the JWT is verified, the server extracts the user information and performs any necessary authorization checks based on the user's claims (such as roles or permissions) contained within the JWT.

	8. Response Handling: Depending on the outcome of the authentication and authorization checks, the server processes the request and sends an appropriate response back to the client.

	9. Token Expiration: Optionally, JWTs can have an expiration time (JWT expiration claim) to limit their validity period. If the JWT has expired, the client may need to re-authenticate to obtain a new token.

	10. Logout and Token Revocation: To invalidate a JWT (for example, during user logout or in case of a security incident), the server can maintain a blacklist of revoked tokens or use other mechanisms to manage token revocation.

	- By following these steps, JWT-based authentication provides a stateless and scalable approach to authenticating users in web applications and APIs.

- Compare and contrast unit, integration and end-to-end tests.
	- Unit Tests:
		- Scope: Test individual components or units of code in isolation.
		- Dependencies: Mock or stub external dependencies.
		- Purpose: Verify specific functionality of units.
		- Speed: Fast execution.
		
	- Integration Tests:
		- Scope: Test interaction between different components or modules.
		- Dependencies: Real or simulated interactions with external dependencies.
		- Purpose: Ensure integrated components function correctly together.
		- Speed: Slower than unit tests.

	- End-to-End Tests:
		- Scope: Test entire application workflow from start to finish.
		- Dependencies: Real interactions with entire application stack.
		- Purpose: Verify application functionality from user's perspective.
		- Speed: Slowest execution.

	- In summary, unit tests focus on individual components, integration tests verify interactions between components, and end-to-end tests validate the entire application workflow. Each type of test serves a unique purpose in ensuring software quality.

- What is a mock? What are some things you would mock?
	- A mock, in the context of software testing, is a simulated object that mimics the behavior of a real object or component within a system. Mocks are used to replace real components or dependencies during testing in order to isolate the unit under test and control its behavior in a predictable manner.
	- Some things you could mock: External services, dependencies, and UI components.

- What is continuous integration?
	- Continuous Integration (CI) is a software development practice where developers frequently integrate their code changes into a shared repository, such as version control systems like Git, throughout the development process. Each integration triggers an automated build process that compiles the code, runs tests, and performs other validation steps.

- What is an environment variable and what are they used for?
	- An environment variable is a dynamic-named value that can affect the way running processes will behave on a computer. They are part of the environment in which a process runs and can be accessed by software to determine various settings, configurations, or system properties.
	- Environment variables are used for configuration, system information, security, customization, and inter-process communication. 

- What is TDD? What are some benefits and drawbacks?
	- Test-Driven Development (TDD) is a software development approach where tests are written before the actual implementation code.
	- Benefits: Improve code quality, Early bug detection, Design clarity, Regression testing, Increased productivity
	- Drawbacks: Initial learning curve, Time investment, Over-reliance on tests, and Test maintenance

- What is the value of using JSONSchema for validation?
	- Using JSONSchema for validation improves data quality, interoperability, and developer productivity by providing a standardized, automated, and well-documented approach to defining and enforcing data schemas for JSON-based systems.

- What are some ways to decide which code to test?
	- Critical Paths: Focus on testing code that is critical to the functionality of the application. Prioritize testing code paths that handle important business logic, user interactions, or core functionality.

	- Complexity: Test code that is complex or has multiple execution paths. Complex code is more likely to contain bugs, so thorough testing helps identify and address potential issues.

	- Customer Requirements: Test code that implements customer requirements, user stories, or acceptance criteria. Ensure that the tests cover the expected behavior and use cases specified by stakeholders or users.

	- Performance and Security: Consider testing code for performance and security concerns, such as resource usage, scalability, and vulnerability to attacks. Performance and security testing help identify bottlenecks, vulnerabilities, and potential risks in the application.

- What does `RETURNING` do in SQL? When would you use it?
	- You would use the RETURNING clause when you need to retrieve specific column values that were affected by an INSERT, UPDATE, or DELETE operation. This can be helpful for various scenarios such as:

		- Obtaining auto-generated keys after an insert operation.
		- Auditing changes made to data by fetching updated or deleted values.
		- Returning specific data to the application for further processing or reporting.

- What are some differences between Web Sockets and HTTP?
	- Web Sockets and HTTP are used for communication over the web, but they have different characteristics and are suited for different types of applications. HTTP is well-suited for traditional request-response interactions, while Web Sockets are ideal for real-time, bidirectional communication.

- Did you prefer using Flask over Express? Why or why not (there is no right
  answer here --- we want to see how you think about technology)?
	- I prefer Express over Flask because Express is fast and provides a streamlined platform for building web servers and API's. I also like that Express has a wide variety of packages and modules available through npm. 
